#' Summarizes Peak Matrix Scores by Cell from Sparse Matrices in Parallel
#'
#' This function processes a sparse matrix to summarize peak scores for each cell,
#' based on a peak matrix generated by the Archer getPeakMatrix function.
#' It efficiently handles large datasets using data.table for data manipulation
#' and parallel computing to enhance performance. It requires 'colData' with specific
#' columns as indicated in 'colNames'.
#'
#' @param sparse_matrix A sparse matrix object from the Matrix package, expected to be
#'        the output of a peak matrix computation.
#' @param colData A data.table or convertible structure containing metadata for the matrix
#'        columns. This parameter must include all columns specified in 'colNames'.
#' @param colNames A character vector specifying the names of columns in 'colData' that
#'        will be used for grouping and parallel computation.
#'
#' @return A data.table containing the summarized occurrence counts of matrix values, grouped
#'         by the specified 'colNames' and including additional identifiers and group information.
#'
#' @importFrom data.table data.table
#' @importFrom Matrix sparseMatrix
#' @importFrom parallel mclapply detectCores
#' @examples
#' # Create a sparse matrix
#' library(Matrix)
#' sparse_matrix <- Matrix(c(0,0,2:0), 3, 5, sparse = TRUE)
#'
#' # Create column data as a data.table
#' library(data.table)
#' colData <- data.table(cell_names = c("Cell1", "Cell2", "Cell3"),
#'                       group = c("A", "A", "B"))
#' colNames <- c("group")
#'
#' # Calculate occurrences
#' results <- summarize_peak_matrix(sparse_matrix, colData, colNames)
#' print(results)
#'
#' @export
summarize_peak_matrix <- function(sparse_matrix, colData, colNames) {
    # Ensure the input matrix is a sparse matrix
    if (!inherits(sparse_matrix, "sparseMatrix")) {
        stop("Input must be a sparse matrix.")
    }

    # Convert colData to data.table if not already
    if (!inherits(colData, "data.table")) {
        colData <- as.data.table(colData)
    }
    
    # Ensure colData has the required columns
    if (!all(colNames %in% names(colData))) {
        stop(paste("colData must include the following columns:", paste(colNames, collapse=", ")))
    }

    # Add cell names to colData if not present
    if (!"cell_names" %in% names(colData)) {
        colData[, cell_names := rownames(colData)]  # Use rownames as cell_names
    }

    # Check for adequate unique values for effective parallelism
    if (length(unique(colData[[colNames[1]]])) < 2) {
        warning("Not enough unique values for effective parallelism; consider using a different column or method.")
    }

    # Use the first column name specified for parallel operation
    parallel_col <- colNames[1]

    # Process each group in parallel
    results <- mclapply(unique(colData[[parallel_col]]), function(group_val) {
        cols_in_group <- which(colData[[parallel_col]] == group_val)
        
        # Process each column in the current group
        group_results <- lapply(cols_in_group, function(col) {
            column_data <- as.vector(sparse_matrix[, col, drop = FALSE])
            temp_counts <- as.data.table(table(column_data))
            setnames(temp_counts, c("value", "count"))
            
            # Add additional grouping information and column identifier
            temp_counts[, (colNames) := lapply(colNames, function(cn) colData[[cn]][col])]
            temp_counts[, column_name := colData$cell_names[col]]
            return(temp_counts)
        })
        
        # Combine results for the current group
        return(rbindlist(group_results))
    }, mc.cores = detectCores()/2)  # Use half of available cores for parallel processing

    # Combine all results into one data.table
    occurrence_table <- rbindlist(results, use.names = TRUE, fill = TRUE)

    # Return the compiled data table with occurrences and additional info
    return(occurrence_table)
}